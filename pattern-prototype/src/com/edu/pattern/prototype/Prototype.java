package com.edu.pattern.prototype;

public class Prototype {

    /**
     *
     *
     * 原型模式：
     * DTO、VO、POJO、Entity
     *
     * DTO 和VO存在一些属性名称、类型都相同
     *
     * 数据库中表查询出来的数据会赋值到DTO
     *
     * MVC中的Model把DTO的值赋值给VO
     *
     * 再把VO中的值传输到View中
     *
     * 复制：就是要把DTO中每一个属性的值赋值到VO中的每一个属性的值，
     * 属性名称相同，属性类型相同
     *
     * apache 反射去实现（原型模式）
     *
     * clone
     *
     * 把对象中配置的依赖关系，在每次使用对象之前，都会创建一个新的对象
     * ，并且会将依赖关系完整的赋值给这个新创建的对象
     * scope="prototype"
     *
     * Spring 默认是单例模式
     *
     *
     *
     * DO：
     * domain object持久对象
     *
     * 就是从现实世界中抽象出来的有形或无形的业务实体。
     *
     * PO：
     * persistant object持久对象
     *
     * 最形象的理解就是一个PO就是数据库中的一条记录。
     * 好处是可以把一条记录作为一个对象处理，可以方便的转为其它对象。
     *
     *  BO：
     * business object业务对象
     *
     * 主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。
     * 比如一个简历，有教育经历、工作经历、社会关系等等。
     * 我们可以把教育经历对应一个PO，工作经历对应一个PO，社会关系对应一个PO。
     * 建立一个对应简历的BO对象处理简历，每个BO包含这些PO。
     * 这样处理业务逻辑时，我们就可以针对BO去处理。
     *
     * VO ：
     * value object值对象
     * ViewObject表现层对象
     *
     * 主要对应界面显示的数据对象。对于一个WEB页面，或者SWT、SWING的一个界面，用一个VO对象对应整个界面的值。
     *
     * DTO ：
     * Data Transfer Object数据传输对象
     * 主要用于远程调用等需要大量传输对象的地方。
     * 比如我们一张表有100个字段，那么对应的PO就有100个属性。
     * 但是我们界面上只要显示10个字段，
     * 客户端用WEB service来获取数据，没有必要把整个PO对象传递到客户端，
     * 这时我们就可以用只有这10个属性的DTO来传递结果到客户端，这样也不会暴露服务端表结构.到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO
     *
     * POJO ：
     * plain ordinary java object 简单ava对象
     * 个人感觉POJO是最参见最多变的对象，是一个中间对象，也是我们最常打交道的对象。
     *
     * 一个POJO持久化以后就是PO
     * 直接用它传递、传递过程中就是DTO
     * 直接用来对应表示层就是VO
     *
     * DAO：
     * data access object数据访问对象
     * 这个大家最熟悉，和上面几个O区别最大，基本没有互相转化的可能性和必要.
     * 主要用来封装对数据库的访问。通过它可以把POJO持久化为PO，用PO组装出来VO、DTO
     */
}
