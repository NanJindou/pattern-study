package com.edu.pattern.proxy;

/**
 * 代理模式的作用：
 * AOP实现、拦截器、中介、黄牛、媒婆、解耦
 * 专人做专事、自己不想做但是又不能不做的事情
 *
 *
 * 代理：静态代理、动态代理
 * 代理角色、被代理角色（目标角色）、由被代理角色来做最终的决定
 * 代理角色通常来说会持有 被代理角色对象 的引用
 * （以便于代理角色完成工作之前或者之后能找到被代理角色，能够统治被代理对象）
 *
 *
 *  静态代理：
 *
 *
 *
 *  动态代理的原理：
 *  JDK：
 *  1、拿到被代理对象的引用，并且获取它的所有的接口。反射获取
 *  2、JDK Proxy类重新生成一个新的类，同时新的类要实现被代理类所有实现
 *  3、动态生成Java代码，把新加的业务逻辑方法由一定的逻辑代码去调用（在代码中体现）
 *  4、编译新生成的Java代码.class
 *  5、再重新加载到JVM中运行
 *  以上这个过程就叫做字节码生成
 *
 *  JDK中有个规范：只要是$符号开头的一般都是自动生成的
 *
 *  通过反编译工具可以查看源代码
 */
public class proxy {
}
